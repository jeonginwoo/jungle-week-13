# JUNGLE WEEK 13

> 나만의 무기 준비하기

**요구사항**

**1. 회원 가입 API**
- [x] username, password를 Client에서 전달받기  
- [x] username은  `최소 4자 이상, 10자 이하이며 알파벳 소문자(a~z), 숫자(0~9)`로 구성되어야 한다.  
- [x] password는  `최소 8자 이상, 15자 이하이며 알파벳 대소문자(a~z, A~Z), 숫자(0~9), 특수문자`로 구성되어야 한다.  
- [x] DB에 중복된 username이 없다면 회원을 저장하고 Client 로 성공했다는 메시지, 상태코드 반환하기  
- [x] 회원 권한 부여하기 (ADMIN, USER) - ADMIN 회원은 모든 게시글, 댓글 수정 / 삭제 가능  


**2. 로그인 API**
- [x] username, password를 Client에서 전달받기
- [x] DB에서 username을 사용하여 저장된 회원의 유무를 확인하고 있다면 password 비교하기
- [x] 로그인 성공 시, 로그인에 성공한 유저의 정보와 JWT를 활용하여 토큰을 발급하고,
     발급한 토큰을 Header에 추가하고 성공했다는 메시지, 상태코드 와 함께 Client에 반환하기


**3. 댓글 작성 API**
- [x] 토큰을 검사하여, 유효한 토큰일 경우에만 댓글 작성 가능
- [x] 선택한 게시글의 DB 저장 유무를 확인하기
- [x] 선택한 게시글이 있다면 댓글을 등록하고 등록된 댓글 반환하기

**4. 댓글 수정 API**
- [x] 토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 수정 가능
- [x] 선택한 댓글의 DB 저장 유무를 확인하기
- [x] 선택한 댓글이 있다면 댓글 수정하고 수정된 댓글 반환하기


**5. 댓글 삭제 API**
- [x] 토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 삭제 가능
- [x] 선택한 댓글의 DB 저장 유무를 확인하기
- [x] 선택한 댓글이 있다면 댓글 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기


**6. 예외 처리**
- [ ] 토큰이 필요한 API 요청에서 토큰을 전달하지 않았거나 정상 토큰이 아닐 때는 "토큰이 유효하지 않습니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
- [x] 토큰이 있고, 유효한 토큰이지만 해당 사용자가 작성한 게시글/댓글이 아닌 경우에는 “작성자만 삭제/수정할 수 있습니다.”라는 에러메시지와 statusCode: 400을 Client에 반환하기
- [x] DB에 이미 존재하는 username으로 회원가입을 요청한 경우 "중복된 username 입니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
- [x] 로그인 시, 전달된 username과 password 중 맞지 않는 정보가 있다면 "회원을 찾을 수 없습니다."라는 에러메시지와 statusCode: 400을 Client에 반환하기

---

<br/>

### 1. 처음 설계한 API 명세서에 변경사항이 있었나요?  
처음 설계에서 미처 반영하지 못한 api들과 api에 대한 정보를 추가하는 등의 변경사항이 있었습니다.  
[API 명세서 보러가기](https://www.notion.so/API-12e71470148e809e9832ef5b8210d0ce)

<br/>

### 2. ERD를 먼저 설계한 후 Entity를 개발했을 때 어떤 점이 도움이 되셨나요?  
데이터베이스 구조와 각 테이블 간의 관계를 명확히 파악할 수 있어 Entity를 작성할 때 효율적으로 진행할 수 있었습니다.
![image](https://github.com/user-attachments/assets/09bbd801-3437-47c1-a039-0c9697262ff3)

<br/>

### 3. JWT를 사용하여 인증/인가를 구현했을 때의 장점은 무엇일까요?  
* **자체적으로 인증 정보를 포함**  
JWT는 인증 정보를 자체적으로 포함하므로 서버가 세션을 별도로 관리하지 않아도 됩니다.  
* **분산 시스템에 적합**  
JWT는 클라이언트와 서버 간의 stateless 통신을 지원하므로 마이크로서비스 같은 분산 시스템에서 특히 유리합니다.  
* **확장성**  
JWT는 사용자의 권한과 정보를 토큰에 쉽게 포함할 수 있어, 유연한 인증/인가 체계를 구현할 수 있습니다.  
* **보안성**  
토큰이 서명되어 있어 데이터의 변조를 방지할 수 있습니다.  

<br/>

### 4. JWT를 사용한 인증/인가의 한계점은 무엇일까요?  
* **토큰 탈취 위험**  
JWT는 클라이언트가 보관해야 하는데, 만약 토큰이 탈취되면 탈취한 사람이 그 토큰을 사용해 권한을 남용할 수 있습니다.  
* **토큰 만료 후 처리 문제**  
만약 JWT가 만료되었을 때, 이를 적절히 갱신하는 로직이 필요합니다. 특히 로그아웃 시 토큰을 강제로 무효화하는 작업이 복잡할 수 있습니다.  
* **토큰 크기 문제**  
JWT는 자체적으로 정보를 포함하므로, 길이가 길어질 수 있습니다. 이는 네트워크 트래픽에 부담을 줄 수 있습니다.  

<br/>

### 5. 댓글 기능이 있는 블로그에서 댓글이 달려있는 게시글을 삭제하려고 한다면 무슨 문제가 발생할까요?  
댓글이 달린 게시글을 삭제하면 해당 게시글에 연관된 댓글들도 함께 처리해야 하는 문제가 발생합니다. 이를 해결하지 않으면 데이터베이스에 고아 댓글(연결된 게시글이 없는 댓글)이 남아 데이터 일관성을 해칠 수 있습니다.  
* **해결 방법**
  * 외래 키 제약 조건 설정하기 (자동 삭제)
  * 수동으로 삭제하기 (세밀한 제어 가능, 데이터 보존 및 기록 관리, 성능 고려, 정확한 삭제 조건 지정 가능)

<br/>

### 6. IoC / DI에 대해 간략하게 설명해 주세요!
* **IoC (Inversion of Control)**: 제어의 역전이란, 객체의 생성과 흐름 제어를 개발자가 아닌 외부에서 관리하는 방식입니다. 이는 객체 간의 결합도를 낮춰 유연성과 테스트 가능성을 높여줍니다.  
* **DI (Dependency Injection)**: 의존성 주입이란, 객체가 의존하는 다른 객체를 직접 생성하는 것이 아니라, 외부에서 필요한 의존성을 주입받는 방식입니다. 이를 통해 객체 간 결합도를 줄이고, 코드의 재사용성과 유지보수성을 높일 수 있습니다.
